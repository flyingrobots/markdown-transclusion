diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 53e0bc6..e3289c4 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -26,15 +26,15 @@ jobs:
     - name: Install dependencies
       run: npm ci
     
+    - name: Build
+      run: npm run build
+    
     - name: Run linter
       run: npm run lint
     
     - name: Run tests
       run: npm test -- --coverage
     
-    - name: Build
-      run: npm run build
-    
     - name: Upload coverage
       if: matrix.node-version == '20.x'
       uses: codecov/codecov-action@v3
diff --git a/NEEDSTESTS.md b/NEEDSTESTS.md
new file mode 100644
index 0000000..f817cf9
--- /dev/null
+++ b/NEEDSTESTS.md
@@ -0,0 +1,148 @@
+# Test Coverage Needs
+
+Based on the coverage report, here are the areas that need additional test coverage to reach 95% thresholds:
+
+## Critical Files Needing Tests
+
+### 1. `src/cli.ts` (0% coverage)
+- [ ] Test help display (`--help`, `-h`)
+- [ ] Test version display (`--version`, `-v`)
+- [ ] Test reading from stdin
+- [ ] Test reading from file
+- [ ] Test writing to stdout
+- [ ] Test writing to output file
+- [ ] Test error handling for missing files
+- [ ] Test strict mode exit codes
+- [ ] Test validate-only mode
+- [ ] Test variable substitution via CLI
+- [ ] Test base path option
+- [ ] Test log level options
+
+### 2. `src/utils/logger.ts` (15.25% coverage)
+**Uncovered lines: 36-72, 80-107, 115-172, 187-197**
+- [ ] Test LoggerFactory creation
+- [ ] Test different log levels (ERROR, WARN, INFO, DEBUG)
+- [ ] Test log level filtering
+- [ ] Test formatted output with colors
+- [ ] Test error logging with stack traces
+- [ ] Test info and debug message formatting
+- [ ] Test timestamp formatting
+- [ ] Test logger instance management
+
+### 3. `src/utils/result.ts` (39.28% coverage)
+**Uncovered lines: 27, 34, 44-47, 57-60, 70-73, 80-83, 90-93**
+- [ ] Test Result.ok() creation
+- [ ] Test Result.error() creation
+- [ ] Test map() transformation
+- [ ] Test flatMap() transformation
+- [ ] Test mapError() transformation
+- [ ] Test unwrap() method
+- [ ] Test unwrapOr() method
+- [ ] Test match() pattern matching
+
+### 4. `src/utils/transclusionProcessor.ts` (64.44% coverage)
+**Uncovered lines: 54-108, 138**
+- [ ] Test processVariables() with nested variables
+- [ ] Test processVariables() with circular references
+- [ ] Test processVariables() with missing variables
+- [ ] Test formatBytes() helper function
+- [ ] Test performance metrics calculation
+- [ ] Test error accumulation during processing
+
+### 5. `src/utils/LineTranscluder.ts` (83.33% coverage)
+**Uncovered lines: 61-67, 101-112**
+- [ ] Test max file size limit enforcement
+- [ ] Test performance tracking and metrics
+- [ ] Test memory usage tracking
+- [ ] Test cache hit/miss statistics
+
+### 6. `src/utils/safeFileReader.ts` (85.1% coverage)
+**Uncovered lines: 80-90, 117, 150-160**
+- [ ] Test Windows path normalization
+- [ ] Test path traversal with backslashes
+- [ ] Test BOM handling for different encodings
+- [ ] Test file size validation edge cases
+
+### 7. `src/fileCache.ts` (86.95% coverage)
+**Uncovered lines: 9-25**
+- [ ] Test MemoryFileCache implementation
+- [ ] Test cache expiration
+- [ ] Test cache size limits
+- [ ] Test concurrent access patterns
+
+### 8. `src/utils/cliArgs.ts` (89.92% coverage)
+**Uncovered lines: 54, 117-118, 141, 154, 167, 189, 211, 258, 270, 291-292, 300**
+- [ ] Test error messages for invalid arguments
+- [ ] Test multiple variable parsing
+- [ ] Test conflicting options
+- [ ] Test default values
+
+### 9. `src/stream.ts` (90.9% coverage)
+**Uncovered lines: 37, 48, 58**
+- [ ] Test stream error handling
+- [ ] Test transform stream edge cases
+- [ ] Test backpressure handling
+
+### 10. Minor Coverage Gaps
+
+#### `src/utils/pathTokens.ts` (91.22% coverage)
+**Uncovered lines: 120-130**
+- [ ] Test complex nested variable substitution
+
+#### `src/utils/fileValidation.ts` (92.59% coverage)
+**Uncovered lines: 40, 64**
+- [ ] Test binary file detection edge cases
+
+#### `src/resolver.ts` (97.36% coverage)
+**Uncovered lines: 80**
+- [ ] Test heading resolution error case
+
+#### `src/security.ts` (94.23% coverage)
+**Uncovered lines: 27-31**
+- [ ] Test path validation error messages
+
+#### `src/utils/contentProcessing.ts` (85.71% coverage)
+**Uncovered lines: 16, 21**
+- [ ] Test line ending normalization edge cases
+
+## Integration Tests Needed
+
+### CLI Integration Tests
+- [ ] Test piping with other commands
+- [ ] Test signal handling (SIGINT, SIGTERM)
+- [ ] Test large file processing
+- [ ] Test concurrent file access
+- [ ] Test with symbolic links
+- [ ] Test with different file encodings
+
+## Property-Based Tests Needed
+
+### Additional Edge Cases
+- [ ] Test with extremely long file paths
+- [ ] Test with unicode in file paths
+- [ ] Test with special characters in headings
+- [ ] Test with malformed transclusion syntax
+
+## Performance Tests Needed
+
+- [ ] Benchmark large file processing
+- [ ] Test memory usage with circular references
+- [ ] Test cache effectiveness
+- [ ] Test streaming performance
+
+## Priority Order
+
+1. **High Priority** (blocking CI):
+   - CLI tests (currently causing failures)
+   - Logger tests (very low coverage)
+   - Result utility tests (core functionality)
+
+2. **Medium Priority** (core functionality):
+   - TransclusionProcessor variable handling
+   - SafeFileReader edge cases
+   - Stream error handling
+
+3. **Low Priority** (nice to have):
+   - Performance metrics
+   - Cache optimization tests
+   - Integration test improvements
\ No newline at end of file
diff --git a/jest.config.js b/jest.config.js
index ab30cc6..0320172 100644
--- a/jest.config.js
+++ b/jest.config.js
@@ -5,7 +5,8 @@ module.exports = {
   testMatch: ['**/*.test.ts'],
   collectCoverageFrom: [
     'src/**/*.ts',
-    '!src/**/*.d.ts'
+    '!src/**/*.d.ts',
+    '!src/cli.ts'
   ],
   coverageDirectory: 'coverage',
   coverageReporters: ['text', 'lcov', 'html'],
diff --git a/src/cli.ts b/src/cli.ts
index 0357c1a..49647ab 100644
--- a/src/cli.ts
+++ b/src/cli.ts
@@ -1,112 +1,15 @@
 #!/usr/bin/env node
 
-import { createReadStream, createWriteStream } from 'fs';
-import { resolve } from 'path';
-import { pipeline } from 'stream/promises';
-import { TransclusionTransform } from './stream';
-import { parseCliArgs, getHelpText, getVersionText } from './utils/cliArgs';
-import { StreamLogger, LogLevel } from './utils/logger';
-import type { TransclusionOptions } from './types';
+import { runCli } from './cliCore';
 
-/**
- * Main CLI entry point
- */
-async function main(): Promise<void> {
-  // Parse arguments
-  const argsResult = parseCliArgs(process.argv);
-  
-  if (!argsResult.ok) {
-    const logger = new StreamLogger(process.stderr, process.stdout);
-    logger.error(`${argsResult.error.message}`);
-    process.exit(1);
-  }
-  
-  const args = argsResult.value;
-  
-  // Handle help and version flags
-  if (args.help) {
-    console.log(getHelpText());
-    process.exit(0);
-  }
-  
-  if (args.version) {
-    console.log(getVersionText());
-    process.exit(0);
-  }
-  
-  // Create logger with proper streams for POSIX compliance
-  const logger = new StreamLogger(
-    process.stderr,
-    process.stdout,
-    args.logLevel !== undefined ? args.logLevel : LogLevel.INFO
-  );
-  
-  try {
-    // Build transclusion options
-    const options: TransclusionOptions = {
-      basePath: args.basePath || process.cwd(),
-      extensions: args.extensions || ['md', 'markdown'],
-      variables: args.variables,
-      strict: args.strict,
-      maxDepth: args.maxDepth || 10,
-      validateOnly: args.validateOnly
-    };
-    
-    // Create transform stream
-    const transform = new TransclusionTransform(options);
-    
-    // Set up input stream
-    const input = args.input
-      ? createReadStream(resolve(args.input))
-      : process.stdin;
-    
-    // Set up output stream
-    const output = args.output
-      ? createWriteStream(resolve(args.output))
-      : process.stdout;
-    
-    // Handle transform errors
-    transform.on('error', (error) => {
-      logger.error('Transclusion error', error);
-      if (options.strict) {
-        process.exit(1);
-      }
-    });
-    
-    // Process the stream
-    await pipeline(input, transform, output);
-    
-    // Check for errors after processing
-    const errors = transform.errors;
-    if (errors.length > 0) {
-      for (const error of errors) {
-        logger.warn(`[${error.path}${error.line ? `:${error.line}` : ''}] ${error.message}`);
-      }
-      
-      if (options.strict) {
-        logger.error(`Processing failed with ${errors.length} error(s)`);
-        process.exit(1);
-      }
-    }
-    
-    // Validation mode feedback
-    if (args.validateOnly) {
-      if (errors.length > 0) {
-        logger.info(`Validation completed with ${errors.length} issue(s)`);
-      } else {
-        logger.info('Validation completed successfully');
-      }
-    }
-    
-  } catch (error) {
-    logger.error('Fatal error', error);
-    process.exit(1);
-  }
-}
-
-// Run the CLI
 if (require.main === module) {
-  main().catch((error) => {
+  runCli({
+    argv: process.argv,
+    stdin: process.stdin,
+    stdout: process.stdout,
+    stderr: process.stderr,
+    exit: process.exit
+  }).catch((error) => {
     console.error('Unexpected error:', error);
     process.exit(1);
   });
diff --git a/src/cliCore.ts b/src/cliCore.ts
new file mode 100644
index 0000000..88f3e2e
--- /dev/null
+++ b/src/cliCore.ts
@@ -0,0 +1,117 @@
+import { createReadStream, createWriteStream } from 'fs';
+import { resolve } from 'path';
+import { pipeline } from 'stream/promises';
+import { TransclusionTransform } from './stream';
+import { parseCliArgs, getHelpText, getVersionText } from './utils/cliArgs';
+import { StreamLogger, LogLevel } from './utils/logger';
+import type { TransclusionOptions } from './types';
+
+export interface CliOptions {
+  argv: string[];
+  stdin: NodeJS.ReadableStream;
+  stdout: NodeJS.WriteStream;
+  stderr: NodeJS.WriteStream;
+  exit: (code: number) => void;
+}
+
+/**
+ * Core CLI logic extracted for testability
+ */
+export async function runCli(options: CliOptions): Promise<void> {
+  const { argv, stdin, stdout, stderr, exit } = options;
+  
+  // Parse arguments
+  const argsResult = parseCliArgs(argv);
+  
+  if (!argsResult.ok) {
+    const logger = new StreamLogger(stderr, stdout);
+    logger.error(`${argsResult.error.message}`);
+    exit(1);
+    return;
+  }
+  
+  const args = argsResult.value;
+  
+  // Handle help and version flags
+  if (args.help) {
+    stdout.write(getHelpText() + '\n');
+    exit(0);
+    return;
+  }
+  
+  if (args.version) {
+    stdout.write(getVersionText() + '\n');
+    exit(0);
+    return;
+  }
+  
+  // Create logger with proper streams for POSIX compliance
+  const logger = new StreamLogger(
+    stderr,
+    stdout,
+    args.logLevel !== undefined ? args.logLevel : LogLevel.INFO
+  );
+  
+  try {
+    // Build transclusion options
+    const transclusionOptions: TransclusionOptions = {
+      basePath: args.basePath || process.cwd(),
+      extensions: args.extensions || ['md', 'markdown'],
+      variables: args.variables,
+      strict: args.strict,
+      maxDepth: args.maxDepth || 10,
+      validateOnly: args.validateOnly
+    };
+    
+    // Create transform stream
+    const transform = new TransclusionTransform(transclusionOptions);
+    
+    // Set up input stream
+    const input = args.input
+      ? createReadStream(resolve(args.input))
+      : stdin;
+    
+    // Set up output stream
+    const output = args.output
+      ? createWriteStream(resolve(args.output))
+      : stdout;
+    
+    // Handle transform errors
+    transform.on('error', (error) => {
+      logger.error('Transclusion error', error);
+      if (transclusionOptions.strict) {
+        exit(1);
+      }
+    });
+    
+    // Process the stream
+    await pipeline(input, transform, output);
+    
+    // Check for errors after processing
+    const errors = transform.errors;
+    if (errors.length > 0) {
+      for (const error of errors) {
+        logger.warn(`[${error.path}${error.line ? `:${error.line}` : ''}] ${error.message}`);
+      }
+      
+      if (transclusionOptions.strict) {
+        logger.error(`Processing failed with ${errors.length} error(s)`);
+        exit(1);
+        return;
+      }
+    }
+    
+    // Validation mode feedback
+    if (args.validateOnly) {
+      if (errors.length > 0) {
+        logger.info(`Validation completed with ${errors.length} issue(s)`);
+      } else {
+        logger.info('Validation completed successfully');
+      }
+    }
+    
+  } catch (error) {
+    logger.error('Fatal error', error);
+    exit(1);
+  }
+}
\ No newline at end of file
diff --git a/src/utils/logger.ts b/src/utils/logger.ts
index 931f492..dc8ebb9 100644
--- a/src/utils/logger.ts
+++ b/src/utils/logger.ts
@@ -146,18 +146,18 @@ export class StreamLogger implements Logger {
   
   info(message: string, data?: unknown): void {
     if (this.level >= LogLevel.INFO) {
-      this.errorStream.write(this.format(LogLevel.INFO, message) + '\n');
+      this.outStream.write(this.format(LogLevel.INFO, message) + '\n');
       if (data) {
-        this.errorStream.write(JSON.stringify(data, null, 2) + '\n');
+        this.outStream.write(JSON.stringify(data, null, 2) + '\n');
       }
     }
   }
   
   debug(message: string, data?: unknown): void {
     if (this.level >= LogLevel.DEBUG) {
-      this.errorStream.write(this.format(LogLevel.DEBUG, message) + '\n');
+      this.outStream.write(this.format(LogLevel.DEBUG, message) + '\n');
       if (data) {
-        this.errorStream.write(JSON.stringify(data, null, 2) + '\n');
+        this.outStream.write(JSON.stringify(data, null, 2) + '\n');
       }
     }
   }
diff --git a/tests/cliCore.test.ts b/tests/cliCore.test.ts
new file mode 100644
index 0000000..5110562
--- /dev/null
+++ b/tests/cliCore.test.ts
@@ -0,0 +1,431 @@
+import { runCli } from '../src/cliCore';
+import { Readable, Writable } from 'stream';
+import { TransclusionTransform } from '../src/stream';
+import { parseCliArgs, getHelpText, getVersionText } from '../src/utils/cliArgs';
+import { createReadStream, createWriteStream } from 'fs';
+import { pipeline } from 'stream/promises';
+
+jest.mock('fs');
+jest.mock('stream/promises');
+jest.mock('../src/stream');
+jest.mock('../src/utils/cliArgs');
+
+describe('cliCore', () => {
+  let mockStdin: Readable;
+  let mockStdout: any;  // NodeJS.WriteStream is complex, using any for test
+  let mockStderr: any;  // NodeJS.WriteStream is complex, using any for test
+  let mockExit: jest.Mock;
+  let stdoutData: string[];
+  let stderrData: string[];
+
+  beforeEach(() => {
+    jest.clearAllMocks();
+    
+    // Create mock streams
+    stdoutData = [];
+    stderrData = [];
+    
+    mockStdin = new Readable({
+      read() {}
+    });
+    
+    // Create minimal WriteStream mocks
+    mockStdout = {
+      write: jest.fn((chunk: any, encoding?: any, callback?: any) => {
+        stdoutData.push(chunk.toString());
+        if (typeof encoding === 'function') {
+          encoding();
+          return true;
+        }
+        if (callback) callback();
+        return true;
+      })
+    };
+    
+    mockStderr = {
+      write: jest.fn((chunk: any, encoding?: any, callback?: any) => {
+        stderrData.push(chunk.toString());
+        if (typeof encoding === 'function') {
+          encoding();
+          return true;
+        }
+        if (callback) callback();
+        return true;
+      })
+    };
+    
+    mockExit = jest.fn();
+    
+    // Default mock implementations
+    (pipeline as jest.Mock).mockResolvedValue(undefined);
+    (TransclusionTransform as unknown as jest.Mock).mockImplementation(() => ({
+      on: jest.fn(),
+      errors: []
+    }));
+  });
+
+  describe('Help and Version', () => {
+    it('should display help with --help flag', async () => {
+      const helpText = 'Usage: markdown-transclusion [options]';
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: { help: true } 
+      });
+      (getHelpText as jest.Mock).mockReturnValue(helpText);
+      
+      await runCli({
+        argv: ['node', 'cli.js', '--help'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(stdoutData.join('')).toBe(helpText + '\n');
+      expect(mockExit).toHaveBeenCalledWith(0);
+    });
+    
+    it('should display version with --version flag', async () => {
+      const versionText = '1.0.0';
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: { version: true } 
+      });
+      (getVersionText as jest.Mock).mockReturnValue(versionText);
+      
+      await runCli({
+        argv: ['node', 'cli.js', '--version'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(stdoutData.join('')).toBe(versionText + '\n');
+      expect(mockExit).toHaveBeenCalledWith(0);
+    });
+  });
+
+  describe('Argument Parsing', () => {
+    it('should handle parse errors', async () => {
+      const errorMessage = 'Unknown flag: --invalid';
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: false, 
+        error: new Error(errorMessage) 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js', '--invalid'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(stderrData.join('')).toContain(errorMessage);
+      expect(mockExit).toHaveBeenCalledWith(1);
+    });
+  });
+
+  describe('Stream Processing', () => {
+    it('should process stdin to stdout by default', async () => {
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: {} 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(TransclusionTransform).toHaveBeenCalledWith({
+        basePath: process.cwd(),
+        extensions: ['md', 'markdown'],
+        variables: undefined,
+        strict: undefined,
+        maxDepth: 10,
+        validateOnly: undefined
+      });
+      
+      expect(pipeline).toHaveBeenCalledWith(
+        mockStdin,
+        expect.any(Object),
+        mockStdout
+      );
+      expect(mockExit).not.toHaveBeenCalled();
+    });
+    
+    it('should read from file when input is specified', async () => {
+      const mockFileStream = new Readable({ read() {} });
+      (createReadStream as jest.Mock).mockReturnValue(mockFileStream);
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: { input: 'input.md' } 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js', 'input.md'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(createReadStream).toHaveBeenCalledWith(expect.stringContaining('input.md'));
+      expect(pipeline).toHaveBeenCalledWith(
+        mockFileStream,
+        expect.any(Object),
+        mockStdout
+      );
+    });
+    
+    it('should write to file when output is specified', async () => {
+      const mockFileStream = new Writable({ write() {} });
+      (createWriteStream as jest.Mock).mockReturnValue(mockFileStream);
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: { output: 'output.md' } 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js', '--output', 'output.md'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(createWriteStream).toHaveBeenCalledWith(expect.stringContaining('output.md'));
+      expect(pipeline).toHaveBeenCalledWith(
+        mockStdin,
+        expect.any(Object),
+        mockFileStream
+      );
+    });
+  });
+
+  describe('Error Handling', () => {
+    it('should handle transform errors in non-strict mode', async () => {
+      const error = new Error('File not found');
+      const mockTransform = {
+        on: jest.fn(),
+        errors: []
+      };
+      
+      (TransclusionTransform as unknown as jest.Mock).mockImplementation(() => mockTransform);
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: {} 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      // Simulate error event
+      const errorHandler = mockTransform.on.mock.calls.find(call => call[0] === 'error')[1];
+      errorHandler(error);
+      
+      expect(stderrData.join('')).toContain('Transclusion error');
+      expect(mockExit).not.toHaveBeenCalled();
+    });
+    
+    it('should exit on transform errors in strict mode', async () => {
+      const error = new Error('File not found');
+      const mockTransform = {
+        on: jest.fn(),
+        errors: []
+      };
+      
+      (TransclusionTransform as unknown as jest.Mock).mockImplementation(() => mockTransform);
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: { strict: true } 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js', '--strict'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      // Simulate error event
+      const errorHandler = mockTransform.on.mock.calls.find(call => call[0] === 'error')[1];
+      errorHandler(error);
+      
+      expect(stderrData.join('')).toContain('Transclusion error');
+      expect(mockExit).toHaveBeenCalledWith(1);
+    });
+    
+    it('should report accumulated errors after processing', async () => {
+      const mockTransform = {
+        on: jest.fn(),
+        errors: [
+          { path: 'file1.md', line: 10, message: 'Missing reference' },
+          { path: 'file2.md', message: 'File not found' }
+        ]
+      };
+      
+      (TransclusionTransform as unknown as jest.Mock).mockImplementation(() => mockTransform);
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: {} 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(stderrData.join('')).toContain('[file1.md:10] Missing reference');
+      expect(stderrData.join('')).toContain('[file2.md] File not found');
+      expect(mockExit).not.toHaveBeenCalled();
+    });
+    
+    it('should exit on accumulated errors in strict mode', async () => {
+      const mockTransform = {
+        on: jest.fn(),
+        errors: [
+          { path: 'file1.md', message: 'Missing reference' }
+        ]
+      };
+      
+      (TransclusionTransform as unknown as jest.Mock).mockImplementation(() => mockTransform);
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: { strict: true } 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js', '--strict'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(stderrData.join('')).toContain('Processing failed with 1 error(s)');
+      expect(mockExit).toHaveBeenCalledWith(1);
+    });
+    
+    it('should handle fatal errors', async () => {
+      const error = new Error('ENOENT: no such file');
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: { input: 'missing.md' } 
+      });
+      (pipeline as jest.Mock).mockRejectedValue(error);
+      
+      await runCli({
+        argv: ['node', 'cli.js', 'missing.md'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(stderrData.join('')).toContain('Fatal error');
+      expect(mockExit).toHaveBeenCalledWith(1);
+    });
+  });
+
+  describe('Validation Mode', () => {
+    it('should report validation success', async () => {
+      const mockTransform = {
+        on: jest.fn(),
+        errors: []
+      };
+      
+      (TransclusionTransform as unknown as jest.Mock).mockImplementation(() => mockTransform);
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: { validateOnly: true } 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js', '--validate-only'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(stdoutData.join('')).toContain('Validation completed successfully');
+    });
+    
+    it('should report validation issues', async () => {
+      const mockTransform = {
+        on: jest.fn(),
+        errors: [
+          { path: 'file.md', message: 'Missing reference' },
+          { path: 'file2.md', message: 'Invalid path' }
+        ]
+      };
+      
+      (TransclusionTransform as unknown as jest.Mock).mockImplementation(() => mockTransform);
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: { validateOnly: true } 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js', '--validate-only'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(stdoutData.join('')).toContain('Validation completed with 2 issue(s)');
+    });
+  });
+
+  describe('Options Configuration', () => {
+    it('should pass all options to TransclusionTransform', async () => {
+      const options = {
+        basePath: '/custom/path',
+        extensions: ['md', 'txt'],
+        variables: { lang: 'en', version: 'v2' },
+        strict: true,
+        maxDepth: 5,
+        validateOnly: true,
+        logLevel: 2
+      };
+      
+      (parseCliArgs as jest.Mock).mockReturnValue({ 
+        ok: true, 
+        value: options 
+      });
+      
+      await runCli({
+        argv: ['node', 'cli.js'],
+        stdin: mockStdin,
+        stdout: mockStdout,
+        stderr: mockStderr,
+        exit: mockExit
+      });
+      
+      expect(TransclusionTransform).toHaveBeenCalledWith({
+        basePath: options.basePath,
+        extensions: options.extensions,
+        variables: options.variables,
+        strict: options.strict,
+        maxDepth: options.maxDepth,
+        validateOnly: options.validateOnly
+      });
+    });
+  });
+});
\ No newline at end of file
diff --git a/tests/utils/logger.test.ts b/tests/utils/logger.test.ts
new file mode 100644
index 0000000..b8be307
--- /dev/null
+++ b/tests/utils/logger.test.ts
@@ -0,0 +1,318 @@
+import { 
+  LogLevel, 
+  ConsoleLogger, 
+  SilentLogger, 
+  StreamLogger,
+  createLogger,
+  type Logger 
+} from '../../src/utils/logger';
+import { Writable } from 'stream';
+
+describe('Logger', () => {
+  let consoleErrorSpy: jest.SpyInstance;
+  let consoleWarnSpy: jest.SpyInstance;
+  let consoleInfoSpy: jest.SpyInstance;
+  let consoleDebugSpy: jest.SpyInstance;
+  
+  beforeEach(() => {
+    // Spy on console methods
+    consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
+    consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();
+    consoleInfoSpy = jest.spyOn(console, 'info').mockImplementation();
+    consoleDebugSpy = jest.spyOn(console, 'debug').mockImplementation();
+  });
+  
+  afterEach(() => {
+    jest.restoreAllMocks();
+  });
+  
+  describe('ConsoleLogger', () => {
+    it('should respect log levels', () => {
+      const logger = new ConsoleLogger(LogLevel.WARN);
+      
+      logger.error('Error message');
+      logger.warn('Warning message');
+      logger.info('Info message');
+      logger.debug('Debug message');
+      
+      expect(consoleErrorSpy).toHaveBeenCalledTimes(1);
+      expect(consoleWarnSpy).toHaveBeenCalledTimes(1);
+      expect(consoleInfoSpy).not.toHaveBeenCalled();
+      expect(consoleDebugSpy).not.toHaveBeenCalled();
+    });
+    
+    it('should format messages with level prefix', () => {
+      const logger = new ConsoleLogger(LogLevel.ERROR);
+      
+      logger.error('Test error');
+      
+      expect(consoleErrorSpy).toHaveBeenCalled();
+      const call = consoleErrorSpy.mock.calls[0];
+      const message = call[0];
+      
+      // Check format: [LEVEL] message
+      expect(message).toBe('[ERROR] Test error');
+    });
+    
+    it('should handle data parameter', () => {
+      const logger = new ConsoleLogger(LogLevel.DEBUG);
+      const data = { key: 'value', count: 42 };
+      
+      logger.error('Error with data', data);
+      logger.warn('Warn with data', data);
+      logger.info('Info with data', data);
+      logger.debug('Debug with data', data);
+      
+      expect(consoleErrorSpy).toHaveBeenCalledWith(expect.any(String), data);
+      expect(consoleWarnSpy).toHaveBeenCalledWith(expect.any(String), data);
+      expect(consoleInfoSpy).toHaveBeenCalledWith(expect.any(String), data);
+      expect(consoleDebugSpy).toHaveBeenCalledWith(expect.any(String), data);
+    });
+    
+    it('should handle empty data parameter', () => {
+      const logger = new ConsoleLogger(LogLevel.INFO);
+      
+      logger.info('Message without data');
+      
+      expect(consoleInfoSpy).toHaveBeenCalledWith(expect.any(String), '');
+    });
+    
+    it('should change log level dynamically', () => {
+      const logger = new ConsoleLogger(LogLevel.ERROR);
+      
+      logger.info('Should not appear');
+      expect(consoleInfoSpy).not.toHaveBeenCalled();
+      
+      logger.setLevel(LogLevel.INFO);
+      logger.info('Should appear');
+      expect(consoleInfoSpy).toHaveBeenCalledTimes(1);
+    });
+    
+    it('should handle all log levels', () => {
+      const logger = new ConsoleLogger(LogLevel.DEBUG);
+      
+      logger.error('Error');
+      logger.warn('Warning');
+      logger.info('Info');
+      logger.debug('Debug');
+      
+      expect(consoleErrorSpy).toHaveBeenCalledTimes(1);
+      expect(consoleWarnSpy).toHaveBeenCalledTimes(1);
+      expect(consoleInfoSpy).toHaveBeenCalledTimes(1);
+      expect(consoleDebugSpy).toHaveBeenCalledTimes(1);
+    });
+  });
+  
+  describe('SilentLogger', () => {
+    it('should not output anything', () => {
+      const logger = new SilentLogger();
+      
+      logger.error('Error');
+      logger.warn('Warning');
+      logger.info('Info');
+      logger.debug('Debug');
+      
+      expect(consoleErrorSpy).not.toHaveBeenCalled();
+      expect(consoleWarnSpy).not.toHaveBeenCalled();
+      expect(consoleInfoSpy).not.toHaveBeenCalled();
+      expect(consoleDebugSpy).not.toHaveBeenCalled();
+    });
+    
+    it('should allow setting level without effect', () => {
+      const logger = new SilentLogger();
+      
+      logger.setLevel(LogLevel.DEBUG);
+      logger.debug('Still silent');
+      
+      expect(consoleDebugSpy).not.toHaveBeenCalled();
+    });
+  });
+  
+  describe('StreamLogger', () => {
+    let errorStream: MockStream;
+    let outStream: MockStream;
+    
+    class MockStream extends Writable {
+      public data: string[] = [];
+      
+      _write(chunk: any, encoding: string, callback: Function): void {
+        this.data.push(chunk.toString());
+        callback();
+      }
+      
+      write(chunk: any): boolean {
+        this._write(chunk, 'utf8', () => {});
+        return true;
+      }
+    }
+    
+    beforeEach(() => {
+      errorStream = new MockStream();
+      outStream = new MockStream();
+    });
+    
+    it('should write to appropriate streams', () => {
+      const logger = new StreamLogger(errorStream as any, outStream as any, LogLevel.DEBUG);
+      
+      logger.error('Error message');
+      logger.warn('Warning message');
+      logger.info('Info message');
+      logger.debug('Debug message');
+      
+      // Error and warn go to error stream
+      expect(errorStream.data.filter(d => d.includes('ERROR'))).toHaveLength(1);
+      expect(errorStream.data.filter(d => d.includes('WARN'))).toHaveLength(1);
+      expect(errorStream.data.filter(d => d.includes('INFO'))).toHaveLength(0);
+      expect(errorStream.data.filter(d => d.includes('DEBUG'))).toHaveLength(0);
+      
+      // Info and debug go to out stream
+      expect(outStream.data.filter(d => d.includes('INFO'))).toHaveLength(1);
+      expect(outStream.data.filter(d => d.includes('DEBUG'))).toHaveLength(1);
+    });
+    
+    it('should format messages correctly', () => {
+      const logger = new StreamLogger(errorStream as any, outStream as any, LogLevel.INFO);
+      
+      logger.info('Test message');
+      
+      const output = outStream.data[0];
+      expect(output).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z INFO\s+Test message\n$/);
+    });
+    
+    it('should handle data objects', () => {
+      const logger = new StreamLogger(errorStream as any, outStream as any, LogLevel.INFO);
+      const data = { test: 'value', nested: { prop: 123 } };
+      
+      logger.info('Message with data', data);
+      
+      expect(outStream.data).toHaveLength(2);
+      expect(outStream.data[0]).toContain('Message with data');
+      
+      const jsonData = JSON.parse(outStream.data[1]);
+      expect(jsonData).toEqual(data);
+    });
+    
+    it('should respect log level', () => {
+      const logger = new StreamLogger(errorStream as any, outStream as any, LogLevel.WARN);
+      
+      logger.debug('Debug');
+      logger.info('Info');
+      logger.warn('Warning');
+      logger.error('Error');
+      
+      expect(outStream.data).toHaveLength(0); // Nothing goes to out stream
+      expect(errorStream.data.filter(d => d.includes('WARN'))).toHaveLength(1);
+      expect(errorStream.data.filter(d => d.includes('ERROR'))).toHaveLength(1);
+      expect(errorStream.data.filter(d => d.includes('DEBUG'))).toHaveLength(0);
+      expect(errorStream.data.filter(d => d.includes('INFO'))).toHaveLength(0);
+    });
+    
+    it('should handle default streams', () => {
+      // Just verify it doesn't crash without streams
+      const logger = new StreamLogger();
+      
+      // Should write to process.stderr and process.stdout
+      const stderrSpy = jest.spyOn(process.stderr, 'write').mockImplementation();
+      const stdoutSpy = jest.spyOn(process.stdout, 'write').mockImplementation();
+      
+      logger.error('Error');
+      logger.info('Info');
+      
+      expect(stderrSpy).toHaveBeenCalled();
+      expect(stdoutSpy).toHaveBeenCalled();
+      
+      stderrSpy.mockRestore();
+      stdoutSpy.mockRestore();
+    });
+  });
+  
+  describe('createLogger', () => {
+    it('should create ConsoleLogger by default', () => {
+      const logger = createLogger();
+      expect(logger).toBeInstanceOf(ConsoleLogger);
+    });
+    
+    it('should create SilentLogger when silent option is true', () => {
+      const logger = createLogger({ silent: true });
+      expect(logger).toBeInstanceOf(SilentLogger);
+    });
+    
+    it('should create StreamLogger when streams are provided', () => {
+      const errorStream = new Writable();
+      const outStream = new Writable();
+      
+      const logger = createLogger({
+        streams: { error: errorStream as any, out: outStream as any }
+      });
+      
+      expect(logger).toBeInstanceOf(StreamLogger);
+    });
+    
+    it('should respect log level option', () => {
+      const logger = createLogger({ level: LogLevel.ERROR });
+      
+      logger.warn('Should not appear');
+      logger.error('Should appear');
+      
+      expect(consoleWarnSpy).not.toHaveBeenCalled();
+      expect(consoleErrorSpy).toHaveBeenCalledTimes(1);
+    });
+    
+    it('should handle partial options', () => {
+      const logger1 = createLogger({ level: LogLevel.DEBUG });
+      const logger2 = createLogger({ silent: false });
+      
+      expect(logger1).toBeInstanceOf(ConsoleLogger);
+      expect(logger2).toBeInstanceOf(ConsoleLogger);
+    });
+  });
+  
+  describe('LogLevel enum', () => {
+    it('should have correct numeric values', () => {
+      expect(LogLevel.ERROR).toBe(0);
+      expect(LogLevel.WARN).toBe(1);
+      expect(LogLevel.INFO).toBe(2);
+      expect(LogLevel.DEBUG).toBe(3);
+    });
+    
+    it('should have correct string representations', () => {
+      expect(LogLevel[LogLevel.ERROR]).toBe('ERROR');
+      expect(LogLevel[LogLevel.WARN]).toBe('WARN');
+      expect(LogLevel[LogLevel.INFO]).toBe('INFO');
+      expect(LogLevel[LogLevel.DEBUG]).toBe('DEBUG');
+    });
+  });
+  
+  describe('Edge Cases', () => {
+    it('should handle undefined and null messages', () => {
+      const logger = new ConsoleLogger(LogLevel.DEBUG);
+      
+      logger.info(undefined as any);
+      logger.info(null as any);
+      logger.info('');
+      
+      expect(consoleInfoSpy).toHaveBeenCalledTimes(3);
+    });
+    
+    it('should handle circular references in data', () => {
+      const logger = new ConsoleLogger(LogLevel.INFO);
+      const circular: any = { name: 'test' };
+      circular.self = circular;
+      
+      // Should not throw
+      expect(() => logger.info('Circular data', circular)).not.toThrow();
+      expect(consoleInfoSpy).toHaveBeenCalled();
+    });
+    
+    it('should handle very long messages', () => {
+      const logger = new ConsoleLogger(LogLevel.INFO);
+      const longMessage = 'x'.repeat(10000);
+      
+      logger.info(longMessage);
+      
+      expect(consoleInfoSpy).toHaveBeenCalled();
+      const call = consoleInfoSpy.mock.calls[0];
+      expect(call[0]).toContain(longMessage);
+    });
+  });
+});
\ No newline at end of file
diff --git a/tests/utils/result.test.ts b/tests/utils/result.test.ts
new file mode 100644
index 0000000..2313dce
--- /dev/null
+++ b/tests/utils/result.test.ts
@@ -0,0 +1,366 @@
+import {
+  Result,
+  Ok,
+  Err,
+  isOk,
+  isErr,
+  mapResult,
+  mapError,
+  andThen,
+  unwrap,
+  unwrapOr
+} from '../../src/utils/result';
+
+describe('Result', () => {
+  describe('Creation', () => {
+    it('should create Ok result', () => {
+      const result = Ok(42);
+      
+      expect(result.ok).toBe(true);
+      expect(isOk(result)).toBe(true);
+      expect(isErr(result)).toBe(false);
+      if (isOk(result)) {
+        expect(result.value).toBe(42);
+      }
+    });
+    
+    it('should create Error result', () => {
+      const error = new Error('Something went wrong');
+      const result = Err(error);
+      
+      expect(result.ok).toBe(false);
+      expect(isOk(result)).toBe(false);
+      expect(isErr(result)).toBe(true);
+      if (isErr(result)) {
+        expect(result.error).toBe(error);
+      }
+    });
+    
+    it('should handle different value types', () => {
+      const stringResult = Ok('hello');
+      const objectResult = Ok({ key: 'value' });
+      const arrayResult = Ok([1, 2, 3]);
+      const nullResult = Ok(null);
+      
+      if (isOk(stringResult)) expect(stringResult.value).toBe('hello');
+      if (isOk(objectResult)) expect(objectResult.value).toEqual({ key: 'value' });
+      if (isOk(arrayResult)) expect(arrayResult.value).toEqual([1, 2, 3]);
+      if (isOk(nullResult)) expect(nullResult.value).toBe(null);
+    });
+  });
+  
+  describe('mapResult', () => {
+    it('should transform Ok value', () => {
+      const result = Ok(5);
+      const mapped = mapResult(result, x => x * 2);
+      
+      expect(isOk(mapped)).toBe(true);
+      if (isOk(mapped)) {
+        expect(mapped.value).toBe(10);
+      }
+    });
+    
+    it('should not transform Error', () => {
+      const error = new Error('Failed');
+      const result = Err(error);
+      const mapped = mapResult(result, (x: number) => x * 2);
+      
+      expect(isErr(mapped)).toBe(true);
+      if (isErr(mapped)) {
+        expect(mapped.error).toBe(error);
+      }
+    });
+    
+    it('should handle type transformations', () => {
+      const result = Ok('42');
+      const mapped = mapResult(result, str => parseInt(str, 10));
+      
+      if (isOk(mapped)) {
+        expect(mapped.value).toBe(42);
+        expect(typeof mapped.value).toBe('number');
+      }
+    });
+    
+    it('should chain multiple maps', () => {
+      const result = Ok(2);
+      const step1 = mapResult(result, x => x * 3);    // 6
+      const step2 = mapResult(step1, x => x + 4);     // 10
+      const final = mapResult(step2, x => x / 2);     // 5
+      
+      if (isOk(final)) {
+        expect(final.value).toBe(5);
+      }
+    });
+  });
+  
+  describe('andThen (flatMap)', () => {
+    it('should chain Ok results', () => {
+      const divide = (a: number, b: number): Result<number, Error> => {
+        if (b === 0) {
+          return Err(new Error('Division by zero'));
+        }
+        return Ok(a / b);
+      };
+      
+      const result = andThen(
+        andThen(Ok(10), x => divide(x, 2)),
+        x => divide(x, 2.5)
+      );
+      
+      expect(isOk(result)).toBe(true);
+      if (isOk(result)) {
+        expect(result.value).toBe(2);
+      }
+    });
+    
+    it('should short-circuit on Error', () => {
+      const divide = (a: number, b: number): Result<number, Error> => {
+        if (b === 0) {
+          return Err(new Error('Division by zero'));
+        }
+        return Ok(a / b);
+      };
+      
+      const result = andThen(
+        andThen(Ok(10), x => divide(x, 0)),  // Error here
+        x => divide(x, 2)                    // Should not execute
+      );
+      
+      expect(isErr(result)).toBe(true);
+      if (isErr(result)) {
+        expect(result.error.message).toBe('Division by zero');
+      }
+    });
+    
+    it('should propagate initial Error', () => {
+      const error = new Error('Initial error');
+      const result = andThen(
+        Err(error),
+        x => Ok(x * 2)
+      );
+      
+      expect(isErr(result)).toBe(true);
+      if (isErr(result)) {
+        expect(result.error).toBe(error);
+      }
+    });
+  });
+  
+  describe('mapError', () => {
+    it('should transform Error', () => {
+      const result = Err(new Error('Original'));
+      const mapped = mapError(result, err => new Error(`Wrapped: ${err.message}`));
+      
+      expect(isErr(mapped)).toBe(true);
+      if (isErr(mapped)) {
+        expect(mapped.error.message).toBe('Wrapped: Original');
+      }
+    });
+    
+    it('should not transform Ok', () => {
+      const result = Ok(42);
+      const mapped = mapError(result, (err: Error) => new Error('Should not run'));
+      
+      expect(isOk(mapped)).toBe(true);
+      if (isOk(mapped)) {
+        expect(mapped.value).toBe(42);
+      }
+    });
+    
+    it('should handle error type transformations', () => {
+      interface CustomError {
+        code: string;
+        details: string;
+      }
+      
+      const result = Err(new Error('Network failed'));
+      const mapped = mapError(result, (err): CustomError => ({
+        code: 'NETWORK_ERROR',
+        details: err.message
+      }));
+      
+      if (isErr(mapped)) {
+        expect(mapped.error).toEqual({
+          code: 'NETWORK_ERROR',
+          details: 'Network failed'
+        });
+      }
+    });
+  });
+  
+  describe('unwrap', () => {
+    it('should return value for Ok', () => {
+      const result = Ok('success');
+      expect(unwrap(result)).toBe('success');
+    });
+    
+    it('should throw for Error', () => {
+      const result = Err(new Error('Failed'));
+      expect(() => unwrap(result)).toThrow('Failed');
+    });
+    
+    it('should preserve error when throwing', () => {
+      const error = new Error('Test error');
+      const result = Err(error);
+      
+      try {
+        unwrap(result);
+      } catch (e) {
+        expect(e).toBe(error);
+      }
+    });
+  });
+  
+  describe('unwrapOr', () => {
+    it('should return value for Ok', () => {
+      const result = Ok('success');
+      expect(unwrapOr(result, 'default')).toBe('success');
+    });
+    
+    it('should return default for Error', () => {
+      const result = Err(new Error('Failed'));
+      expect(unwrapOr(result, 'default')).toBe('default');
+    });
+    
+    it('should handle different default types', () => {
+      const result1 = Err(new Error('Failed'));
+      const result2 = Err(new Error('Failed'));
+      const result3 = Err(new Error('Failed'));
+      
+      expect(unwrapOr(result1, 0)).toBe(0);
+      expect(unwrapOr(result2, [])).toEqual([]);
+      expect(unwrapOr(result3, { key: 'default' })).toEqual({ key: 'default' });
+    });
+  });
+  
+  describe('Type Guards', () => {
+    it('should narrow types with isOk', () => {
+      const result: Result<string, Error> = Ok('test');
+      
+      if (isOk(result)) {
+        // TypeScript should know result.value is available
+        const value: string = result.value;
+        expect(value).toBe('test');
+      }
+    });
+    
+    it('should narrow types with isErr', () => {
+      const result: Result<string, Error> = Err(new Error('test'));
+      
+      if (isErr(result)) {
+        // TypeScript should know result.error is available
+        const error: Error = result.error;
+        expect(error.message).toBe('test');
+      }
+    });
+  });
+  
+  describe('Real-world Examples', () => {
+    it('should handle file reading scenario', () => {
+      const readFile = (path: string): Result<string, Error> => {
+        if (path.includes('..')) {
+          return Err(new Error('Invalid path'));
+        }
+        if (!path.endsWith('.txt')) {
+          return Err(new Error('Not a text file'));
+        }
+        return Ok(`Contents of ${path}`);
+      };
+      
+      const result = mapResult(
+        mapResult(readFile('data.txt'), content => content.toUpperCase()),
+        content => content.split(' ')
+      );
+      
+      expect(isOk(result)).toBe(true);
+      if (isOk(result)) {
+        expect(result.value).toEqual(['CONTENTS', 'OF', 'DATA.TXT']);
+      }
+      
+      const errorResult = readFile('../etc/passwd');
+      expect(isErr(errorResult)).toBe(true);
+      if (isErr(errorResult)) {
+        expect(errorResult.error.message).toBe('Invalid path');
+      }
+    });
+    
+    it('should handle parsing scenario', () => {
+      const parseJSON = <T>(input: string): Result<T, Error> => {
+        try {
+          return Ok(JSON.parse(input));
+        } catch (e) {
+          return Err(e as Error);
+        }
+      };
+      
+      const validResult = parseJSON<{ name: string }>('{"name": "test"}');
+      if (isOk(validResult)) {
+        expect(validResult.value).toEqual({ name: 'test' });
+      }
+      
+      const invalidResult = parseJSON('invalid json');
+      expect(isErr(invalidResult)).toBe(true);
+      if (isErr(invalidResult)) {
+        expect(invalidResult.error.message).toContain('JSON');
+      }
+    });
+    
+    it('should compose multiple operations', () => {
+      const parseNumber = (s: string): Result<number, Error> => {
+        const n = parseInt(s, 10);
+        return isNaN(n) 
+          ? Err(new Error(`Invalid number: ${s}`))
+          : Ok(n);
+      };
+      
+      const divide = (a: number, b: number): Result<number, Error> => {
+        return b === 0
+          ? Err(new Error('Division by zero'))
+          : Ok(a / b);
+      };
+      
+      const calculate = (input: string): Result<number, Error> => {
+        return mapResult(
+          andThen(parseNumber(input), n => divide(100, n)),
+          n => Math.round(n * 100) / 100
+        );
+      };
+      
+      const result1 = calculate('20');
+      if (isOk(result1)) expect(result1.value).toBe(5);
+      
+      const result2 = calculate('0');
+      if (isErr(result2)) expect(result2.error.message).toBe('Division by zero');
+      
+      const result3 = calculate('abc');
+      if (isErr(result3)) expect(result3.error.message).toBe('Invalid number: abc');
+    });
+  });
+  
+  describe('Edge Cases', () => {
+    it('should handle undefined and null in Ok', () => {
+      const undefinedResult = Ok(undefined);
+      const nullResult = Ok(null);
+      
+      expect(isOk(undefinedResult)).toBe(true);
+      expect(isOk(nullResult)).toBe(true);
+      
+      if (isOk(undefinedResult)) expect(undefinedResult.value).toBeUndefined();
+      if (isOk(nullResult)) expect(nullResult.value).toBeNull();
+    });
+    
+    it('should handle non-Error types in Err', () => {
+      const stringError = Err('string error');
+      const numberError = Err(404);
+      const objectError = Err({ code: 'E001', message: 'Custom error' });
+      
+      expect(isErr(stringError)).toBe(true);
+      expect(isErr(numberError)).toBe(true);
+      expect(isErr(objectError)).toBe(true);
+      
+      if (isErr(stringError)) expect(stringError.error).toBe('string error');
+      if (isErr(numberError)) expect(numberError.error).toBe(404);
+      if (isErr(objectError)) expect(objectError.error).toEqual({ code: 'E001', message: 'Custom error' });
+    });
+  });
+});
\ No newline at end of file
